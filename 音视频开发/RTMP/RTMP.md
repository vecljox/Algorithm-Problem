# RTMP Chunk Stream 
允许 RTMP 在单一的底层 TCP 连接上传输多个独立的流数据（例如音频流、视频流、控制命令等），这些数据被划分为小块（chunks）进行传输。  
这种设计可以大幅提高数据传输效率，因为它允许音频、视频和控制信令共享一个 TCP 连接而无需额外的连接。
## Chunking
- 在握手之后，连接会对一个或多个块流进行多路复用。每个块流携带来自一个消息流的某种类型的消息。
- 每个创建的块都有一个唯一的 ID，称为块流 ID。
- 块通过网络传输。在传输过程中，每个块必须在下一个块之前完全发送。
- 在接收端，块根据块流 ID 被组装成消息。
- 块大小在每个方向上独立维护。
  
**分块允许在高级协议中将大消息拆分为更小的消息，例如，防止大低优先级消息（如视频）阻塞较小的高优先级消息（如音频或控制）。**  
**分块还允许以较少的开销发送小消息，因为块头包含了信息的压缩表示，而这些信息本来需要包含在消息本身中。**

### Chunk Format
![image](https://github.com/user-attachments/assets/970d2b84-76a5-488a-a33d-449ec083c9d4)
- #### Basic Header (1 to 3 bytes): 该字段编码了块流 ID 和块类型。块类型标识 ’chunk message header’ 使用的四种格式之一。基本头的长度完全取决于块流 ID，块流 ID 是一个可变长度字段。
  Basic Header分别有1,2,3字节3种版本，块类型由下图fmt字段表示,块基本头中的位 0-5（最低有效位）表示块流 ID。

  - ![image](https://github.com/user-attachments/assets/29431a1f-f4b9-4b63-8acd-ad914d25807a)  
    块流 ID 2-63 可以在该字段的 1 字节版本中编码。

  - ![image](https://github.com/user-attachments/assets/8048d388-87cd-4b66-9ea4-1becd7e7d8cf)  
    块流 ID 64-319 可以在头部的 2 字节形式中编码。ID 计算为（第二个字节 + 64）。

  - ![image](https://github.com/user-attachments/assets/9de6f795-b631-4e65-a8ec-6da934188ff5)  
    块流 ID 64-65599 可以在该字段的 3 字节版本中编码。ID 的计算方法是 ((第三字节) * 256 + (第二字节) + 64)。

- #### Message Header (0, 3, 7, or 11 bytes): 此字段编码有关所发送消息的信息（无论是整体还是部分）。块消息头有四种不同的格式，通过块基本头中的“fmt”字段选择
  - ![image](https://github.com/user-attachments/assets/d9919e08-447d-4fbc-8799-f33c7d7c4d24)  
    类型 0 块头的长度为 11 字节。此类型必须用于块流的开始，并且每当流时间戳向后移动时（例如，由于向后查找）都必须使用。  
    时间戳 (3 字节): 对于类型-0 块，消息的绝对时间戳在此发送。如果时间戳大于或等于 16777215 (十六进制 0xFFFFFF)，则该字段必须为 16777215，表示存在扩展时间戳字段以编码完整的 32 位时间戳。否则，该字段应为整个时间戳。
    
  - ![image](https://github.com/user-attachments/assets/41845f0b-2586-403d-9321-f20e6f1c3883)  
    类型 1 块头的长度为 7 字节。消息流 ID 不包括在内；此块采用与前一个块相同的流 ID。具有可变大小消息的流（例如，许多视频格式）应在每个新消息的第一个块之后使用此格式。
    
  - ![image](https://github.com/user-attachments/assets/043b62e9-42f4-49fd-8f41-3550aa626d8e)  
    类型 2 块头的长度为 3 字节。流 ID 和消息长度均不包含在内；此块与之前的块具有相同的流 ID 和消息长度。具有固定大小消息的流（例如，一些音频和数据格式）应在每个消息的第一个块之后使用此格式。
    
  - 类型 3 块没有消息头。流 ID、消息长度和时间戳增量字段不存在；这种类型的块从前一个块获取相同的块流 ID 的值。
    - 当单个消息被拆分成块时，除了第一个以外的所有消息块都应使用此类型。
    - 由大小、流 ID 和时间间隔完全相同的消息组成的流，在 Type 2 的块之后，应对所有块使用此类型。
    - 如果第一个消息和第二个消息之间的增量与第一个消息的时间戳相同，则类型 3 的块可以立即跟随类型 0 的块，因为不需要类型 2 的块来注册增量。
      
  - 常见头字段
    - timestamp delta (3 bytes): 对于类型 1 或类型 2 的块，前一块的时间戳与当前块的时间戳之间的差异在此发送。如果增量大于或等于 16777215（十六进制 0xFFFFFF），则该字段必须为 16777215，表示存在扩展时间戳字段以编码完整的 32 位增量。否则，该字段应为实际增量。
    - message length (3 bytes): 对于类型为 0 或 1 的块，这里发送的是消息的长度。请注意，这通常与块有效负载的长度不同。块有效负载长度通常是chunk size(最后一个Chunk可能不是)。
    - message type id (1 byte): For a type-0 or type-1 chunk, type of the message is sent here.
    - message stream id (4 bytes): 对于类型 0 的块，存储消息流 ID。消息流 ID 以小端格式存储。**通常，同一块流中的所有消息将来自同一消息流。虽然可以将单独的消息流复用到同一块流中，但这会削弱头部压缩的好处**。然而，如果一个消息流关闭，随后打开另一个消息流，则没有理由不能通过发送一个新的类型 0 块重新使用现有的块流。

- #### Extended Timestamp
  **扩展时间戳字段用于编码大于 16777215 (0xFFFFFF) 的时间戳或时间戳增量；**

    对于不适合 Type 0、1 或 2 块的 24 位字段的时间戳或时间戳增量。该字段编码完整的 32 位时间戳或时间戳增量。

    通过将 Type 0 块的时间戳字段或 Type 1 或 2 块的时间戳增量字段设置为 16777215 (0xFFFFFF)，来指示该字段的存在。

    当同一块流 ID 的最近 Type 0、1 或 2 块指示存在扩展时间戳字段时，该字段存在于 Type 3 块中。
### 示例
#### 示例 1
此示例显示了一串简单的音频消息。此示例演示了信息的冗余性：

![image](https://github.com/user-attachments/assets/ce275b0c-2076-4324-8941-d3392eaf7c09)

下表显示了该流中生成的块。从消息 3 开始，数据传输得到了优化。在此之后，每条消息仅有 1 个字节的开销。

![image](https://github.com/user-attachments/assets/e8f0cf0d-676a-45ed-8fb3-16cecbfb293d)
#### 示例 2
此示例说明了一条消息过长，无法适合 128 字节块，因此被拆分成几个块

![image](https://github.com/user-attachments/assets/74f5c6b6-a115-457f-8dc3-97245ee7dda9)

以下是生成的块：

![image](https://github.com/user-attachments/assets/4f91f255-023b-4749-b811-d63e1a36fb51)

块 1 的头部数据指定整体消息为 307 字节。

注意从这两个例子可以看出，块类型 3 可以以两种不同的方式使用。
- **第一种方式是指定一条消息的延续。**
- **第二种方式是指定一条新消息的开始，其头部可以从现有的状态数据中推导出来。**
